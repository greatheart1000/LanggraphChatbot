# LangGraph 最佳实践

本文档总结了使用 LangGraph 开发应用的最佳实践和推荐做法。

## 1. 代码组织

### 状态定义

**推荐**：使用 TypedDict 和类型提示

```python
from typing import Annotated, TypedDict
from langgraph.graph.message import AnyMessage, add_messages

class GraphState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    context: dict
    metadata: dict
```

**不推荐**：使用普通字典

```python
# 避免这样做
state = {"messages": [], "context": {}}
```

### 节点函数

**推荐**：单一职责，清晰的函数签名

```python
def process_node(state: GraphState) -> dict:
    """处理节点：执行特定功能"""
    # 清晰的逻辑
    result = process(state["data"])
    return {"result": result}
```

**不推荐**：功能混杂，职责不清

```python
# 避免这样做
def do_everything(state):
    # 太多功能混在一起
    pass
```

### 模块化设计

**推荐**：将相关功能组织到模块中

```
my_app/
├── state.py          # 状态定义
├── nodes.py          # 节点函数
├── graph.py          # 图构建
└── main.py           # 入口文件
```

## 2. 状态管理

### 使用 Reducer

**推荐**：使用 Reducer 控制状态更新

```python
from typing import Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]  # 自动追加
    count: int  # 直接覆盖
```

### 状态验证

**推荐**：在节点中验证状态

```python
def process_node(state: GraphState) -> dict:
    if not state.get("required_field"):
        raise ValueError("Missing required field")
    # 处理逻辑
```

### 状态初始化

**推荐**：提供默认值

```python
def initialize_state(input_data: dict) -> GraphState:
    return {
        "messages": input_data.get("messages", []),
        "context": input_data.get("context", {}),
        "metadata": input_data.get("metadata", {})
    }
```

## 3. 错误处理

### 节点级错误处理

**推荐**：在节点中捕获和处理错误

```python
def robust_node(state: GraphState) -> dict:
    try:
        result = process(state)
        return {"result": result}
    except SpecificError as e:
        # 处理特定错误
        return {"error": str(e), "result": None}
    except Exception as e:
        # 记录并重新抛出未知错误
        logger.error(f"Unexpected error: {e}")
        raise
```

### 重试机制

**推荐**：实现重试逻辑

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(3), wait=wait_exponential())
def api_call_node(state: GraphState) -> dict:
    result = call_external_api(state)
    return {"result": result}
```

### 错误状态

**推荐**：使用状态字段表示错误

```python
class GraphState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    error: str | None
    retry_count: int
```

## 4. 性能优化

### 并行执行

**推荐**：使用并行节点提高性能

```python
# 多个节点可以并行执行
builder.add_node("node1", node1)
builder.add_node("node2", node2)
builder.add_edge(START, "node1")
builder.add_edge(START, "node2")  # 并行执行
```

### 缓存

**推荐**：对重复计算使用缓存

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def expensive_computation(input_data: str) -> str:
    # 昂贵的计算
    return result
```

### 异步执行

**推荐**：使用异步节点处理 I/O 操作

```python
async def async_node(state: GraphState) -> dict:
    result = await async_operation(state)
    return {"result": result}
```

## 5. 测试策略

### 单元测试

**推荐**：独立测试每个节点

```python
def test_process_node():
    state = GraphState(
        messages=[],
        data="test"
    )
    result = process_node(state)
    assert result["result"] == "expected"
```

### 集成测试

**推荐**：测试完整的图执行流程

```python
def test_full_graph():
    graph = build_graph()
    result = graph.invoke({
        "messages": [("user", "test")],
        "data": "input"
    })
    assert "expected" in result["result"]
```

### 模拟外部依赖

**推荐**：使用 mock 测试外部服务

```python
from unittest.mock import patch

@patch('external_api.call')
def test_with_mock(mock_call):
    mock_call.return_value = "mocked_result"
    result = node_with_external_call(state)
    assert result == "mocked_result"
```

## 6. 日志和监控

### 结构化日志

**推荐**：使用结构化日志

```python
import logging

logger = logging.getLogger(__name__)

def logged_node(state: GraphState) -> dict:
    logger.info("Processing node", extra={
        "node": "process",
        "state_size": len(state["messages"])
    })
    # 处理逻辑
```

### 追踪执行

**推荐**：使用 LangSmith 追踪

```python
import os

os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_API_KEY"] = "your-key"
os.environ["LANGCHAIN_PROJECT"] = "my-project"
```

## 7. 配置管理

### 环境变量

**推荐**：使用环境变量管理配置

```python
import os

llm_model = os.getenv("LLM_MODEL", "gpt-4o-mini")
max_iterations = int(os.getenv("MAX_ITERATIONS", "10"))
```

### 配置对象

**推荐**：使用配置对象

```python
from dataclasses import dataclass

@dataclass
class GraphConfig:
    llm_model: str = "gpt-4o-mini"
    max_iterations: int = 10
    temperature: float = 0.7

config = GraphConfig()
```

## 8. 文档和注释

### 函数文档

**推荐**：为每个节点函数添加文档字符串

```python
def process_node(state: GraphState) -> dict:
    """
    处理节点：执行数据处理逻辑
    
    Args:
        state: 图的当前状态
        
    Returns:
        包含处理结果的字典
        
    Raises:
        ValueError: 当输入数据无效时
    """
    # 实现
```

### 类型提示

**推荐**：使用完整的类型提示

```python
from typing import Annotated, TypedDict, Literal

def route_node(
    state: GraphState
) -> Literal["path_a", "path_b"]:
    # 实现
```

## 9. 安全考虑

### API 密钥管理

**推荐**：使用环境变量或密钥管理服务

```python
import os
from getpass import getpass

api_key = os.getenv("API_KEY") or getpass("Enter API key: ")
```

**不推荐**：硬编码密钥

```python
# 永远不要这样做
api_key = "sk-1234567890"
```

### 输入验证

**推荐**：验证所有输入

```python
def validate_input(state: GraphState):
    if not isinstance(state.get("messages"), list):
        raise TypeError("messages must be a list")
    # 更多验证
```

## 10. 部署建议

### 检查点配置

**推荐**：生产环境使用数据库检查点

```python
from langgraph.checkpoint.postgres import PostgresSaver

checkpointer = PostgresSaver.from_conn_string(
    os.getenv("DATABASE_URL")
)
graph = builder.compile(checkpointer=checkpointer)
```

### 错误恢复

**推荐**：实现错误恢复机制

```python
def safe_invoke(graph, input_data, config):
    try:
        return graph.invoke(input_data, config)
    except Exception as e:
        logger.error(f"Graph execution failed: {e}")
        # 恢复逻辑
        return fallback_response()
```

## 常见陷阱

### 1. 状态更新错误

**避免**：直接修改状态

```python
# 错误
def bad_node(state: GraphState):
    state["data"] = "modified"  # 不要这样做
    return {}
```

**正确**：返回更新字典

```python
# 正确
def good_node(state: GraphState):
    return {"data": "modified"}
```

### 2. 无限循环

**避免**：没有终止条件的循环

```python
# 错误：可能导致无限循环
def loop_node(state: GraphState):
    while True:
        process(state)
```

**正确**：添加终止条件

```python
# 正确
def loop_node(state: GraphState):
    max_iterations = 10
    for i in range(max_iterations):
        if should_stop(state):
            break
        process(state)
```

### 3. 内存泄漏

**避免**：在状态中累积大量数据

```python
# 错误：可能累积大量数据
def accumulate_node(state: GraphState):
    state["all_data"].append(large_object)
```

**正确**：限制数据大小

```python
# 正确
def accumulate_node(state: GraphState):
    if len(state["all_data"]) > 100:
        state["all_data"] = state["all_data"][-100:]
    state["all_data"].append(new_data)
```

## 总结

遵循这些最佳实践可以帮助您：

1. **编写可维护的代码**：清晰的模块化和文档
2. **提高性能**：并行执行和缓存
3. **增强可靠性**：错误处理和重试机制
4. **便于调试**：日志和监控
5. **安全部署**：配置管理和输入验证

## 下一步

- 查看示例代码：`examples/` 目录
- 学习核心功能：`03-核心功能详解.md`
- 查看官方文档：`docs/docs/` 目录

