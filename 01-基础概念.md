# LangGraph 基础概念

## 什么是 LangGraph？

LangGraph 是一个用于构建有状态、多参与者（multi-actor）应用的框架。它基于图（Graph）的概念，将应用流程表示为节点（Nodes）和边（Edges）的组合。

## 核心概念

### 1. 图（Graph）

图是 LangGraph 的核心数据结构，由节点和边组成：

```python
from langgraph.graph import StateGraph, START, END

# 创建一个图
builder = StateGraph(State)
```

### 2. 节点（Nodes）

节点是图中的处理单元，每个节点执行特定的功能：

```python
def my_node(state: State):
    # 处理逻辑
    return {"result": "processed"}
    
builder.add_node("my_node", my_node)
```

### 3. 边（Edges）

边定义了节点之间的连接关系：

```python
# 直接边
builder.add_edge(START, "my_node")
builder.add_edge("my_node", END)

# 条件边（根据状态路由）
builder.add_conditional_edges(
    "my_node",
    route_function,
    {"path1": "node1", "path2": "node2"}
)
```

### 4. 状态（State）

状态是图在执行过程中传递的数据：

```python
from typing import TypedDict, Annotated
from langgraph.graph.message import AnyMessage, add_messages

class GraphState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    context: dict
    result: str
```

## 基本使用流程

### 步骤 1: 定义状态

```python
from typing import TypedDict, Annotated
from langgraph.graph.message import AnyMessage, add_messages

class MyState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    data: str
```

### 步骤 2: 定义节点函数

```python
def process_node(state: MyState):
    # 处理逻辑
    return {"data": "processed"}
```

### 步骤 3: 构建图

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(MyState)
builder.add_node("process", process_node)
builder.add_edge(START, "process")
builder.add_edge("process", END)
```

### 步骤 4: 编译并运行

```python
graph = builder.compile()

# 运行图
result = graph.invoke({"messages": [], "data": "input"})
```

## 关键特性

### 1. 状态管理
- 状态在节点间自动传递
- 支持状态更新和合并
- 可以使用 Reducer 函数控制状态更新方式

### 2. 条件路由
- 根据状态动态选择执行路径
- 支持复杂的决策逻辑

### 3. 持久化
- 支持检查点（Checkpoint）保存状态
- 可以恢复之前的执行状态

### 4. 流式处理
- 支持实时输出处理结果
- 多种流式模式：values, updates, messages

## 示例：简单对话流程

```python
from typing import Annotated, TypedDict
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import AnyMessage, add_messages

# 定义状态
class ChatState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]

# 初始化 LLM
llm = ChatOpenAI()

# 定义节点
def chatbot_node(state: ChatState):
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# 构建图
builder = StateGraph(ChatState)
builder.add_node("chatbot", chatbot_node)
builder.add_edge(START, "chatbot")
builder.add_edge("chatbot", END)

# 编译
graph = builder.compile()

# 运行
result = graph.invoke({"messages": [("user", "Hello!")]})
```

## 下一步

- 学习如何组合多个示例：查看 `02-示例组合指南.md`
- 深入了解核心功能：查看 `03-核心功能详解.md`
- 查看实际示例：运行 `examples/combining_examples_demo.ipynb`

