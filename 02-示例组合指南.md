# LangGraph 示例组合指南

本指南详细说明如何将 `examples` 文件夹中的多个示例组合在一起，构建更强大的应用。

## 四种组合模式

### 1. 子图组合（推荐）

将独立的图作为子图嵌入到主图中，适合模块化设计。

#### 示例：组合代码助手、RAG 和通用助手

```python
from langgraph.graph import StateGraph, START, END

# 定义主图
builder = StateGraph(MainState)

# 添加子图作为节点
builder.add_node("code_assistant", code_assistant_node)
builder.add_node("rag", rag_node)
builder.add_node("general", general_assistant_node)

# 添加路由逻辑
builder.add_conditional_edges(
    START,
    route_query,
    {
        "code_assistant": "code_assistant",
        "rag": "rag",
        "general": "general"
    }
)
```

**优点**：
- 模块化设计，易于维护
- 子图可以独立测试
- 代码复用性强

**适用场景**：
- 需要多个独立功能模块
- 功能之间有明确的边界
- 需要灵活的路由逻辑

### 2. 节点中调用其他图

在一个图的节点中直接调用另一个已编译的图，适合复杂编排。

#### 示例：编排节点调用代码生成图

```python
def orchestrator_node(state: MainState):
    """编排节点：可以调用其他图"""
    
    # 直接调用其他图
    if "code" in state["messages"][-1].content.lower():
        code_result = code_graph.invoke(state)
        return code_result
    
    # 调用其他函数
    return general_assistant_node(state)
```

**优点**：
- 灵活的动态调用
- 可以根据条件选择不同的处理流程
- 支持复杂的编排逻辑

**适用场景**：
- 需要根据运行时条件选择处理方式
- 复杂的业务逻辑编排
- 需要动态组合不同的处理流程

### 3. 工具封装

将不同示例的功能封装为工具，供 React Agent 使用。

#### 示例：将代码生成和 RAG 封装为工具

```python
from langchain_core.tools import tool
from langgraph.prebuilt import create_react_agent

# 封装代码生成功能
@tool
def generate_code(question: str) -> str:
    """Generate Python code based on a question."""
    # 实现代码生成逻辑
    return code_result

# 封装 RAG 功能
@tool
def search_knowledge_base(query: str) -> str:
    """Search the knowledge base for information."""
    # 实现 RAG 检索逻辑
    return rag_result

# 创建带工具的 Agent
tools = [generate_code, search_knowledge_base]
agent = create_react_agent(llm, tools)
```

**优点**：
- Agent 可以自主选择工具
- 工具可以独立开发和测试
- 符合 ReAct 模式

**适用场景**：
- 需要 Agent 自主决策使用哪些功能
- 功能可以作为独立工具使用
- 符合 ReAct 架构模式

### 4. 特性叠加

持久化、流式处理、记忆管理等功能可以叠加使用。

#### 示例：组合持久化、流式和记忆

```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState

# 添加持久化
memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

# 使用 thread_id 进行会话管理
thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# 流式处理
events = graph.stream(
    {"messages": [("user", "Hello!")]},
    config,
    stream_mode="values"
)
```

**优点**：
- 功能可以独立添加
- 不影响现有代码结构
- 支持渐进式增强

**适用场景**：
- 需要添加持久化能力
- 需要实时反馈
- 需要会话记忆

## 常见组合模式

### 模式 1: RAG + Agent

将 RAG 作为 Agent 的工具，让 Agent 自主决定何时检索。

```python
# 参考示例：
# - examples/rag/adaptive_rag.ipynb
# - examples/create-react-agent.ipynb
```

**实现方式**：
- 将 RAG 检索封装为工具
- Agent 根据问题决定是否使用检索工具

### 模式 2: 代码助手 + 持久化

保存代码生成历史，支持多轮对话。

```python
# 参考示例：
# - examples/code_assistant/langgraph_code_assistant.ipynb
# - examples/persistence.ipynb
```

**实现方式**：
- 使用 MemorySaver 或数据库检查点
- 保存每次代码生成的上下文

### 模式 3: 多 Agent + 子图

每个 Agent 是一个独立的子图，通过路由连接。

```python
# 参考示例：
# - examples/multi_agent/multi-agent-collaboration.ipynb
# - examples/subgraph.ipynb
```

**实现方式**：
- 每个 Agent 构建为独立子图
- 使用路由节点决定调用哪个 Agent

### 模式 4: 流式 + 记忆

实时反馈 + 历史记录，提供更好的用户体验。

```python
# 参考示例：
# - examples/stream-values.ipynb
# - examples/memory/manage-conversation-history.ipynb
```

**实现方式**：
- 使用 stream() 方法实时输出
- 使用持久化保存对话历史

### 模式 5: 分支 + 路由

根据查询类型动态选择处理路径。

```python
# 参考示例：
# - examples/branching.ipynb
```

**实现方式**：
- 使用条件边实现路由
- 根据状态或 LLM 判断选择路径

## 组合示例代码

完整示例代码请查看：`examples/combining_examples_demo.ipynb`

该示例展示了：
1. 如何组合代码助手、RAG 和通用助手
2. 如何添加持久化和流式处理
3. 如何实现条件路由
4. 如何封装功能为工具

## 最佳实践

### 1. 模块化设计
- 将独立功能封装为子图或工具
- 保持每个模块的单一职责

### 2. 状态设计
- 设计清晰的状态结构
- 使用类型提示提高可维护性

### 3. 错误处理
- 在节点中添加错误处理逻辑
- 使用重试机制处理临时失败

### 4. 测试策略
- 独立测试每个子图
- 集成测试组合后的完整流程

## 下一步

- 运行示例代码：`examples/combining_examples_demo.ipynb`
- 查看核心功能详解：`03-核心功能详解.md`
- 学习最佳实践：`04-最佳实践.md`

