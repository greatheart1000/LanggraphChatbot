# TCG 客服场景处理系统 - 使用指南

## 📋 目录

1. [系统概述](#系统概述)
2. [安装配置](#安装配置)
3. [快速开始](#快速开始)
4. [详细使用](#详细使用)
5. [场景扩展](#场景扩展)
6. [常见问题](#常见问题)

## 🎯 系统概述

本系统基于 LangGraph 构建，用于处理 TCG 客服场景。系统支持：

- ✅ 自动识别 14 大类场景及其子类
- ✅ 根据场景类型智能路由处理
- ✅ 支持多轮对话和上下文记忆
- ✅ 流式输出，提供实时反馈
- ✅ 持久化会话状态

## 📦 安装配置

### 1. 安装依赖

```bash
cd 智能客服系统/tcg_customer_support
pip install -r requirements.txt
```

### 2. 设置环境变量

```bash
# Linux/Mac
export OPENAI_API_KEY='your-api-key-here'

# Windows
set OPENAI_API_KEY=your-api-key-here
```

### 3. 解析文档

首先需要解析 Word 文档，提取场景结构：

```bash
python parse_document.py "../TCG 客服场景flow.docx"
```

这将生成 `TCG_客服场景flow_parsed.json` 文件。

## 🚀 快速开始

### 基础使用

```python
from tcg_customer_support_graph import customer_support_graph
import uuid

# 创建会话
thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# 处理用户查询
result = customer_support_graph.invoke(
    {
        "messages": [],
        "user_query": "我想查询订单状态",
        "category": "",
        "subcategory": "",
        "context": {},
        "response": "",
        "next_action": "",
        "history": []
    },
    config
)

print(result["response"])
```

### 运行示例

```bash
python example_usage.py
```

## 📖 详细使用

### 1. 场景分类

系统会自动识别用户查询属于哪个场景：

```python
result = customer_support_graph.invoke(state, config)
category = result["category"]      # 大类场景
subcategory = result["subcategory"] # 子类场景
```

### 2. 流式处理

支持实时输出处理结果：

```python
events = customer_support_graph.stream(
    state,
    config,
    stream_mode="values"
)

for event in events:
    if "category" in event:
        print(f"分类: {event['category']}")
    if "response" in event:
        print(f"回复: {event['response']}")
```

### 3. 多轮对话

使用相同的 `thread_id` 可以保持对话上下文：

```python
# 第一轮
result1 = customer_support_graph.invoke(state1, config)

# 第二轮（自动包含历史）
result2 = customer_support_graph.invoke(state2, config)
```

### 4. 批量处理

可以批量处理多个查询：

```python
queries = ["查询订单", "申请退款", "物流查询"]
results = []

for query in queries:
    thread_id = str(uuid.uuid4())
    config = {"configurable": {"thread_id": thread_id}}
    
    result = customer_support_graph.invoke(
        create_state(query),
        config
    )
    results.append(result)
```

## 🔧 场景扩展

### 添加自定义处理逻辑

修改 `tcg_customer_support_graph.py` 中的 `process_scenario` 函数：

```python
def process_scenario(state: CustomerSupportState) -> Dict:
    # 特定场景的特殊处理
    if state["category"] == "订单查询":
        # 调用订单查询 API
        order_info = query_order_api(state["user_query"])
        return {
            "response": format_order_response(order_info),
            "next_action": "complete"
        }
    
    # 通用处理
    ...
```

### 添加工具

为特定场景添加工具：

```python
from langchain_core.tools import tool

@tool
def query_order(order_id: str) -> str:
    """查询订单信息"""
    # 实现订单查询逻辑
    return order_info

# 在 process_scenario 中使用
tools = [query_order]
agent = create_react_agent(llm, tools)
```

### 自定义路由逻辑

修改路由函数以添加自定义路由逻辑：

```python
def route_after_classification(state: CustomerSupportState) -> str:
    # 添加自定义路由逻辑
    if state["category"] == "紧急问题":
        return "urgent_handler"
    return "get_flow"
```

## 📊 场景处理流程

```
用户查询
  ↓
[分类场景] 
  ├─→ 识别大类场景
  └─→ 识别子类场景
  ↓
[获取流程]
  ├─→ 加载场景描述
  └─→ 加载处理流程
  ↓
[处理场景]
  ├─→ 根据流程生成回复
  └─→ 执行特定操作（如查询订单）
  ↓
返回结果
```

## 🎨 14 大类场景处理

系统支持以下 14 大类场景（具体根据文档内容）：

1. **订单相关**
   - 订单查询
   - 订单修改
   - 订单取消
   - ...

2. **退款相关**
   - 退款申请
   - 退款进度
   - 退款问题
   - ...

3. **物流相关**
   - 物流查询
   - 配送问题
   - 签收问题
   - ...

...（其他 11 大类场景）

每个大类下的子类都会自动识别和处理。

## ❓ 常见问题

### Q1: 如何添加新的场景？

A: 
1. 在 Word 文档中添加新场景
2. 运行 `parse_document.py` 重新解析
3. 系统会自动识别新场景

### Q2: 如何提高分类准确性？

A:
1. 在 `classify_scenario` 中优化提示词
2. 添加更多示例场景
3. 使用更强大的 LLM 模型（如 gpt-4）

### Q3: 如何集成外部 API？

A:
1. 在 `process_scenario` 中添加 API 调用
2. 使用工具封装 API 功能
3. 在特定场景节点中调用

### Q4: 如何保存对话历史？

A:
系统使用 MemorySaver 自动保存。生产环境建议使用数据库：

```python
from langgraph.checkpoint.postgres import PostgresSaver

checkpointer = PostgresSaver.from_conn_string("postgresql://...")
graph = builder.compile(checkpointer=checkpointer)
```

### Q5: 如何处理错误？

A:
系统包含降级处理机制。可以扩展 `fallback_handler` 添加更多错误处理逻辑。

## 🔍 调试技巧

### 1. 查看场景配置

```python
from tcg_customer_support_graph import load_scenarios

scenarios = load_scenarios()
print(json.dumps(scenarios, indent=2, ensure_ascii=False))
```

### 2. 查看图结构

```python
from IPython.display import Image, display

display(Image(customer_support_graph.get_graph().draw_mermaid_png()))
```

### 3. 启用 LangSmith 追踪

```python
import os

os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_API_KEY"] = "your-key"
```

## 📚 相关资源

- LangGraph 文档: `智能客服系统/README.md`
- 示例代码: `example_usage.py`
- 场景解析: `parse_document.py`

## 🆘 获取帮助

如遇问题，请检查：

1. ✅ 依赖是否安装完整
2. ✅ 环境变量是否正确设置
3. ✅ 场景配置文件是否存在
4. ✅ Word 文档格式是否正确

