# LangGraph 核心功能详解

本文档详细说明 LangGraph 的核心功能和使用方法。

## 1. 持久化（Persistence）

持久化允许保存和恢复图的执行状态，支持多轮对话和状态恢复。

### 内存持久化

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
graph = builder.compile(checkpointer=memory)

# 使用 thread_id 管理会话
thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# 运行并保存状态
result = graph.invoke(
    {"messages": [("user", "Hello!")]},
    config
)
```

### 数据库持久化

#### PostgreSQL

```python
from langgraph.checkpoint.postgres import PostgresSaver

checkpointer = PostgresSaver.from_conn_string("postgresql://...")
graph = builder.compile(checkpointer=checkpointer)
```

#### SQLite

```python
from langgraph.checkpoint.sqlite import SqliteSaver

checkpointer = SqliteSaver.from_conn_string("sqlite:///checkpoints.db")
graph = builder.compile(checkpointer=checkpointer)
```

**参考示例**：
- `examples/persistence.ipynb`
- `examples/persistence_postgres.ipynb`
- `examples/persistence_sqlite.ipynb`

## 2. 流式处理（Streaming）

流式处理允许实时获取图的执行结果，提供更好的用户体验。

### 流式模式

#### values 模式
返回每个步骤的完整状态：

```python
events = graph.stream(
    {"messages": [("user", "Hello!")]},
    config,
    stream_mode="values"
)

for event in events:
    print(event["messages"][-1].content)
```

#### updates 模式
只返回更新的部分：

```python
events = graph.stream(
    {"messages": [("user", "Hello!")]},
    config,
    stream_mode="updates"
)

for event in events:
    print(event)  # 只包含更新的字段
```

#### messages 模式
只返回消息：

```python
events = graph.stream(
    {"messages": [("user", "Hello!")]},
    config,
    stream_mode="messages"
)

for event in events:
    print(event.content)
```

**参考示例**：
- `examples/stream-values.ipynb`
- `examples/stream-updates.ipynb`
- `examples/streaming-tokens.ipynb`

## 3. 记忆管理（Memory）

记忆管理用于维护对话历史和上下文信息。

### 管理对话历史

```python
from langgraph.graph import MessagesState

class AgentState(MessagesState):
    context: dict

# 访问历史消息
def agent_node(state: AgentState):
    messages = state["messages"]  # 包含所有历史消息
    # 处理逻辑
    return {"messages": [response]}
```

### 添加摘要

```python
# 当消息过多时，可以添加摘要
def summarize_messages(state: AgentState):
    if len(state["messages"]) > 10:
        # 生成摘要
        summary = generate_summary(state["messages"])
        return {"messages": [("system", summary)]}
```

### 删除消息

```python
def delete_old_messages(state: AgentState):
    # 只保留最近 N 条消息
    return {"messages": state["messages"][-5:]}
```

**参考示例**：
- `examples/memory/manage-conversation-history.ipynb`
- `examples/memory/add-summary-conversation-history.ipynb`
- `examples/memory/delete-messages.ipynb`

## 4. 子图（Subgraphs）

子图允许将复杂的图分解为更小的、可重用的组件。

### 创建子图

```python
# 创建子图
subgraph_builder = StateGraph(SubState)
subgraph_builder.add_node("process", process_node)
subgraph_builder.add_edge(START, "process")
subgraph_builder.add_edge("process", END)
subgraph = subgraph_builder.compile()

# 在主图中使用子图
main_builder = StateGraph(MainState)
main_builder.add_node("subgraph", subgraph)
```

### 状态转换

子图可以有自己的状态结构，需要转换函数：

```python
def transform_state(state: MainState) -> SubState:
    return SubState(data=state["data"])

def transform_back(result: SubState) -> dict:
    return {"result": result["data"]}
```

**参考示例**：
- `examples/subgraph.ipynb`
- `examples/subgraph-transform-state.ipynb`
- `examples/subgraphs-manage-state.ipynb`

## 5. 条件路由（Branching）

条件路由根据状态动态选择执行路径。

### 简单路由

```python
def route_function(state: State) -> str:
    if state["condition"] == "A":
        return "path_a"
    else:
        return "path_b"

builder.add_conditional_edges(
    "decision_node",
    route_function,
    {
        "path_a": "node_a",
        "path_b": "node_b"
    }
)
```

### LLM 路由

使用 LLM 进行智能路由：

```python
from langchain_core.pydantic_v1 import BaseModel, Field

class RouteDecision(BaseModel):
    path: Literal["code", "rag", "general"]

def llm_route(state: State) -> str:
    classifier = llm.with_structured_output(RouteDecision)
    decision = classifier.invoke(state["messages"])
    return decision.path
```

**参考示例**：
- `examples/branching.ipynb`
- `examples/rag/adaptive_rag.ipynb`

## 6. 工具调用（Tool Calling）

工具调用允许 Agent 使用外部工具完成任务。

### 定义工具

```python
from langchain_core.tools import tool

@tool
def search_web(query: str) -> str:
    """Search the web for information."""
    # 实现搜索逻辑
    return results
```

### 创建带工具的 Agent

```python
from langgraph.prebuilt import create_react_agent

tools = [search_web, calculate]
agent = create_react_agent(llm, tools)
```

**参考示例**：
- `examples/create-react-agent.ipynb`
- `examples/tool-calling.ipynb`
- `examples/pass-config-to-tools.ipynb`

## 7. 人机交互（Human-in-the-Loop）

允许在执行过程中暂停并等待人工输入。

### 中断和恢复

```python
from langgraph.types import interrupt

def wait_for_input(state: State):
    # 中断执行，等待用户输入
    interrupt()
    return state

# 恢复执行
graph.invoke(state, config)
```

**参考示例**：
- `examples/create-react-agent-hitl.ipynb`
- `examples/human_in_the_loop/wait-user-input.ipynb`

## 8. 重试机制（Retries）

重试机制可以自动处理临时失败。

### 节点重试

```python
from langgraph.graph import StateGraph

# 在节点中添加重试逻辑
def retry_node(state: State):
    max_retries = 3
    for i in range(max_retries):
        try:
            return process(state)
        except Exception as e:
            if i == max_retries - 1:
                raise
            continue
```

**参考示例**：
- `examples/node-retries.ipynb`
- `examples/extraction/retries.ipynb`

## 9. 可视化（Visualization）

可视化可以帮助理解和调试图的结构。

### 生成图的可视化

```python
# 获取图的 Mermaid 表示
mermaid = graph.get_graph().draw_mermaid()

# 或者直接显示
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
```

**参考示例**：
- `examples/visualization.ipynb`

## 功能组合建议

### 持久化 + 流式
```python
graph = builder.compile(checkpointer=memory)
events = graph.stream(input, config, stream_mode="values")
```

### 记忆 + 持久化
```python
# 持久化自动保存消息历史
graph = builder.compile(checkpointer=memory)
# 下次调用时自动恢复历史
```

### 子图 + 路由
```python
# 根据条件路由到不同的子图
builder.add_conditional_edges(
    "router",
    route_function,
    {"subgraph1": subgraph1, "subgraph2": subgraph2}
)
```

## 下一步

- 查看最佳实践：`04-最佳实践.md`
- 运行示例代码：`examples/` 目录
- 查看官方文档：`docs/docs/` 目录

